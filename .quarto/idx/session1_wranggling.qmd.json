{"title":"Introduction to the Tidyverse for Data wrangling","markdown":{"yaml":{"title":"Introduction to the Tidyverse for Data wrangling","author":"Vivek Jason","format":{"html":{"theme":"materia","toc":true,"toc_float":true}},"editor":"visual"},"headingText":"Garbage in, garbage out, as the saying goes.","containsRefs":false,"markdown":"\n\nData cleaning is arguably the most crucial step in the data analysis pipeline because it directly impacts the accuracy and reliability of insights drawn from the data.\n\n\nWithout thoroughly cleaning the data, we might be working with incorrect, inconsistent, or irrelevant information, leading to potentially faulty conclusions. Data cleaning ensures the data is correctly formatted, accurate, complete, and ready for analysis. It involves dealing with missing values, removing duplicates, correcting inconsistencies, and handling outliers. Only after a rigorous data cleaning process can we trust that our analysis or model will give us meaningful, actionable insights.\n\nThus, while it can be a time-consuming process, skipping or skimping on data cleaning can lead to wasting even more time and resources downstream, as we try to interpret misleading results or troubleshoot models that aren't performing as expected.\n\n![](/images/1_Xhm9c9qDfXa3ZCQjiOvm_w.jpg){fig-align=\"center\"}\n\n### RStudio environment\n\n![](/images/rstudio.png){fig-align=\"center\"}\n\n### Setting a working directory\n\nCheck you working directory by\n\n```{r, eval=FALSE}\ngetwd()\n```\n\nYou can then set your working directory like this\n\n```{r, eval=FALSE}\nsetwd(\"C:\\Users\\VivekJason\\RTraining\\introduction\")\n```\n\n::: callout-warning\n## Setting a work directory like this is called an absolute path and in statistical computing is a frowned upon practice as it locks directories to you system only. Instead we should utilise relative paths.\n:::\n\nA relative path should look like this\n\n```{r, eval=FALSE}\nsetwd(\"../data\")\n```\n\nThere are even better practices for sustainability and reproducibility such but we wont cover those practices here. You can find more information in this [post](https://www.tidyverse.org/articles/2017/12/workflow-vs-script/)\n\n### Reading data into R\n\nThis section demonstrates the fundamental functions required to read and write data in R.\n\nIn base R, there are key functions for reading data:\n\n-   read.table() & read.csv(): used for reading tabular data\n\n-   readLines(): used for reading lines from a text file\n\nCorresponding functions exist for writing data:\n\n-   write.table(): used to write tabular data to text files or connections, such as CSV\n\n-   writeLines(): used to write character data line-by-line to a file or connection\n\nLet's attempt to read data into R using the read.csv() function.\n\n```{r, eval=FALSE, echo=TRUE}\ndf <- read.csv(\"data/yourfilename.csv\")#this is just an example\n```\n\nYou can even pull a csv straight from the web\n\n```{r, warning=FALSE, echo=TRUE}\ndf <- read.csv(\"https://raw.githubusercontent.com/MoH-Malaysia/data-darah-public/main/newdonors_state.csv\")\n```\n\nYou can export he above csv to you computer by\n\n```{r, eval=FALSE}\nwrite.csv(df, \"blood_donor_malaysia.csv\")\n```\n\n### Packages and loading them\n\nIn the olden days you would install the package and call them into you environment like so:\n\n```{r, eval=FALSE}\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n\nBut these days we have packages that deal with even that\n\n```{r}\npacman::p_load(\n     tidyverse\n)\n\n```\n\n# The \"Tidyverse\"\n\nThere are a number of R packages that take advantage of the tidy data form and can be used to do interesting things with data. Many (but not all) of these packages are written by Hadley Wickham and **the collection of packages is often referred to as the \"tidyverse\"** because of their **dependence on and presumption of tidy data**.\n\nA subset of the \"Tidyverse\" packages include:\n\n-   [ggplot2](https://cran.r-project.org/package=ggplot2): a plotting system based on the grammar of graphics\n\n-   [magrittr](https://cran.r-project.org/package=magrittr%22): defines the `%>%` operator for chaining functions together in a series of operations on data\n\n-   [dplyr](https://cran.r-project.org/package=dplyr): a suite of (fast) functions for working with data frames\n\n-   [tidyr](https://cran.r-project.org/package=tidyr): easily tidy data with `pivot_wider()` and `pivot_longer()` functions (also `separate()` and `unite()`)\n\nA complete list can be found here (<https://www.tidyverse.org/packages>).\n\nWe can call in the tidyverse as mentioned in the introduction like this:\n\n```{r}\nlibrary(tidyverse)\n```\n\n## Data Frames\n\nThe **data frame** (or `data.frame`) is a **key data structure** in statistics and in R.\n\nThe basic structure of a data frame is that there is **one observation per row and each column represents a variable, a measure, feature, or characteristic of that observation**.\n\n### Calling in some data\n\nFor the purposes of this session lets utilise the Malaysian COVID-19 deaths linelists maintained by the Ministry of Health on their [Github page](https://github.com/MoH-Malaysia). Codes for each column are as follows:\n\n1.  `date`: yyyy-mm-dd format; date of death\n\n2.  `date_announced`: date on which the death was announced to the public (i.e. registered in the public linelist)\n\n3.  `date_positive`: date of positive sample\n\n4.  `date_doseN`: date of the individual's first/second/third dose (if any)\n\n5.  `brandN`: `p` = Pfizer, `s` = Sinovac, `a` = AstraZeneca, `c` = Cansino, `m` = Moderna, `h` = Sinopharm, `j` = Janssen, `u` = unverified (pending sync with VMS)\n\n6.  `state`: state of residence\n\n7.  `age`: age as an integer; note that it is possible for age to be 0, denoting infants less than 6 months old\n\n8.  `male`: binary variable with 1 denoting male and 0 denoting female\n\n9.  `bid`: binary variable with 1 denoting brought-in-dead and 0 denoting an inpatient death\n\n10. `malaysian`: binary variable with 1 denoting Malaysian and 0 denoting non-Malaysian\n\n11. `comorb`: binary variable with 1 denoting that the individual has comorbidities and 0 denoting no comorbidities declared\n\nLets call in the data:\n\n```{r}\nc19_df <- read.csv(\"https://raw.githubusercontent.com/MoH-Malaysia/covid19-public/main/epidemic/linelist/linelist_deaths.csv\")\n```\n\nCheck the data structure\n\n```{r}\nstr(c19_df)\ndim(c19_df)\n```\n\n# The `dplyr` Package\n\nThe `dplyr` package was developed by Posit (formely RStudio) and is **an optimized and distilled** version of the older `plyr` **package for data manipulation or wrangling**.\n\n![Artwork by Allison Horst on the dplyr package](https://github.com/allisonhorst/stats-illustrations/raw/main/rstats-artwork/dplyr_wrangling.png){alt=\"Artwork by Allison Horst on the dplyr package\" width=\"80%\"}\n\n\\[**Source**: [Artwork by Allison Horst](https://github.com/allisonhorst/stats-illustrations)\\]\n\nThe `dplyr` package does not provide any \"new\" functionality to R per se, in the sense that everything `dplyr` does could already be done with base R, but it **greatly** simplifies existing functionality in R.\n\nOne important contribution of the `dplyr` package is that it **provides a \"grammar\" (in particular, verbs) for data manipulation and for operating on data frames**.\n\nWith this grammar, you can sensibly communicate what it is that you are doing to a data frame that other people can understand (assuming they also know the grammar). This is useful because it **provides an abstraction for data manipulation that previously did not exist**.\n\nAnother useful contribution is that the `dplyr` functions are **very** fast, as many key operations are coded in C++.\n\n### `dplyr` grammar\n\nSome of the key \"verbs\" provided by the `dplyr` package are\n\n-   `select()`: return a subset of the columns of a data frame, using a flexible notation\n\n-   `filter()`: extract a subset of rows from a data frame based on logical conditions\n\n-   `arrange()`: reorder rows of a data frame\n\n-   `rename()`: rename variables in a data frame\n\n-   `mutate()`: add new variables/columns or transform existing variables\n\n-   `summarise()` / `summarize()`: generate summary statistics of different variables in the data frame, possibly within strata\n\n-   `%>%`: the \"pipe\" operator is used to connect multiple verb actions together into a pipelineArtwork by\n\n### `select()`\n\nLets convert the COVID-19 deaths linelist into a tibble first\n\n```{r}\nc19_df <- as_tibble(c19_df)\nstr(c19_df)\n```\n\nThe `select()` function can be used to **select columns of a data frame** that you want to focus on.\n\n::: callout-tip\n### Example\n\nSuppose we wanted to take the last 5 columns only. There are a few ways to do this.\n\nWe could for example use numerical indices:\n\n```{r}\nnames(c19_df)[10:15]\n```\n\nBut we can also use the names directly:\n\n```{r}\nsubset <- select(c19_df, state:comorb)\nhead(subset)\n```\n:::\n\n::: callout-tip\n### Note\n\nThe `:` normally cannot be used with names or strings, but inside the `select()` function you can use it to specify a range of variable names.\n:::\n\nYou can also **omit** variables using the `select()` function by using the negative sign. With `select()` you can do\n\n```{r, eval=FALSE}\nselect(c19_df, -(state:comorb))\n```\n\nThe `select()` function also allows a special syntax that allows you to specify variable names based on patterns. So, for example, if you wanted to keep every variable that ends with a \"2\", we could do\n\n```{r}\nsubset <- select(c19_df, ends_with(c(\"1\", \"2\", \"3\")))\nstr(subset)\n```\n\nOr if we wanted to keep every variable that starts with a \"date\", we could do\n\n```{r}\nsubset <- select(c19_df, contains(\"date\"))\nstr(subset)\n```\n\nYou can also use more general regular expressions if necessary. See the help page (`?select`) for more details.\n\n### `filter()`\n\nThe `filter()` function is used to **extract subsets of rows** from a data frame. This function is similar to the existing `subset()` function in R but is quite a bit faster in my experience.\n\n![Artwork by Allison Horst on filter() function](https://github.com/allisonhorst/stats-illustrations/raw/main/rstats-artwork/dplyr_filter.jpg){alt=\"Artwork by Allison Horst on filter() function\" width=\"80%\"}\n\n\\[**Source**: [Artwork by Allison Horst](https://github.com/allisonhorst/stats-illustrations)\\]\n\n::: callout-tip\n### Example\n\nSuppose we wanted to extract the rows of the `c19_df` data frame of deaths in individuals older than 60, we could do\n\n```{r}\nc19_filter <- filter(c19_df, age > 59)\nstr(c19_filter)\n```\n:::\n\nYou can see that there are now only `r nrow(c19_filter)` rows in the data frame and the distribution of the `age` values is.\n\n```{r}\nsummary(c19_filter$age)\n```\n\nWe can place an arbitrarily complex logical sequence inside of `filter()`, so we could for example extract the rows where age is greater than 60 and nationality (`malaysian`) is equal to 1\n\n```{r}\nc19_filter <- filter(c19_df, age < 21 & malaysian==1)\nselect(c19_filter, date, malaysian, age)\n```\n\nNow there are only `r nrow(c19_filter)` observations where both of those conditions are met.\n\nOther logical operators you should be aware of include:\n\n|  Operator |                  Meaning |                             Example |\n|----------:|-------------------------:|------------------------------------:|\n|      `==` |                   Equals |                     `malaysian== 1` |\n|      `!=` |           Does not equal |                     `malaysian!= 1` |\n|       `>` |             Greater than |                           `age> 60` |\n|      `>=` | Greater than or equal to |                          `age>= 60` |\n|       `<` |                Less than |                           `age< 60` |\n|      `<=` |    Less than or equal to |                          `age<= 60` |\n|    `%in%` |              Included in | `state %in% c(\"Selangor\", \"Johor\")` |\n| `is.na()` |       Is a missing value |                `is.na(date_dose_2)` |\n\n::: callout-tip\n### Note\n\nIf you are ever unsure of how to write a logical statement, but know how to write its opposite, you can use the `!` operator to negate the whole statement.\n\nA common use of this is to identify observations with non-missing data (e.g., `!(is.na(date_dose_2))`).\n:::\n\n### `arrange()`\n\nThe `arrange()` function is used to **reorder rows** of a data frame according to one of the variables/columns. Reordering rows of a data frame (while preserving corresponding order of other columns) is normally a pain to do in R. The `arrange()` function simplifies the process quite a bit.\n\nHere we can order the rows of the data frame by date, so that the first row is the earliest (oldest) observation and the last row is the latest (most recent) observation.\n\n```{r}\nc19_df <- arrange(c19_df, date)\n```\n\nWe can now check the first few rows\n\n```{r}\nhead(select(c19_df, date, age), 3)\n```\n\nColumns can be arranged in descending order too by useing the special `desc()` operator.\n\n```{r}\nc19_df <- arrange(c19_df, desc(date))\n```\n\nLooking at the first three and last three rows shows the dates in descending order.\n\n```{r}\nhead(select(c19_df, date, age), 3)\ntail(select(c19_df, date, age), 3)\n```\n\n### `rename()`\n\n**Renaming a variable** in a data frame in R is surprisingly hard to do! The `rename()` function is designed to make this process easier.\n\nHere you can see the names of the first six variables in the `c19_df` data frame.\n\n```{r}\nhead(c19_df[, 1:6], 3)\n```\n\nThese names are (arbitrarily again) unnecessarily long. Date doesn't need to be repeated for each column name are no other columns that could potentially be confused with the first six. So we can modify cause we're lazy to type long column names when analysing later on.\n\n```{r}\nc19_df <- rename(c19_df, death = date,\n                 announced = date_announced,\n                 positive = date_positive,\n                 dose1 = date_dose1,\n                 dose2 = date_dose2,\n                 dose3 = date_dose3)\nhead(c19_df[, 1:5], 3)\n```\n\nThe syntax inside the `rename()` function is to have the new name on the left-hand side of the `=` sign and the old name on the right-hand side.\n\n### `mutate()`\n\nThe `mutate()` function exists to **compute transformations of variables** in a data frame. Often, you want to create new variables that are derived from existing variables and `mutate()` provides a clean interface for doing that.\n\n![Artwork by Allison Horst on mutate() function](https://github.com/allisonhorst/stats-illustrations/raw/main/rstats-artwork/dplyr_mutate.png){alt=\"Artwork by Allison Horst on mutate() function\" width=\"80%\"}\n\n\\[**Source**: [Artwork by Allison Horst](https://github.com/allisonhorst/stats-illustrations)\\]\n\nFor example, with demographic data, we often want to *categorise data*\n\nHere, we create a `age_cat` variable:\n\n```{r}\nc19_df <- mutate(c19_df, age_cat= ifelse(age<20, \"<19\", \n                                         ifelse(age>59, \">60\", \"20-59\")))\n```\n\nwe can also `recode` category values within a variable, such as\n\n```{r}\nc19_df <- mutate(c19_df,  brand2 = recode(brand2, \n                          \"Pfizer\" = 0, \n                          \"Sinovac\" = 1, \n                          \"AstraZeneca\" = 2, \n                          \"Moderna\" = 2, \n                          \"Pending VMS sync\" = 2, \n                          \"Sinopharm\" = 2))\n```\n\n### `group_by()`\n\nThe `group_by()` function is used to **generate summary statistics** from the data frame within strata defined by a variable.\n\nFor example, in this dataset, you might want to know what the number of deaths in each state is?\n\n**In conjunction** with the `group_by()` function, we often use the `summarise()` function\n\n::: callout-tip\n### Note\n\nThe **general operation** here is a combination of\n\n1.  Splitting a data frame into separate pieces defined by a variable or group of variables (`group_by()`)\n2.  Then, applying a summary function across those subsets (`summarise()`)\n:::\n\n::: callout-tip\n### Example\n\nWe can create a separate data frame that splits the original data frame by state\n\n```{r}\nstate <- group_by(c19_df, state)\n```\n\nWe can then compute summary statistics for each year in the data frame with the `summarise()` function.\n\n```{r}\nsummarise(state, age = mean(age, na.rm = TRUE),\n          age_median= median(age, na.rm = TRUE))\n```\n:::\n\n### `%>%`\n\nThe pipeline operator `%>%` is very handy for **stringing together multiple `dplyr` functions in a sequence of operations**.\n\nNotice above that every time we wanted to apply more than one function, the sequence gets buried in a sequence of nested function calls that is difficult to read, i.e. This **nesting is not a natural way** to think about a sequence of operations.\n\nThe `%>%` operator allows you to string operations in a left-to-right fashion, i.e\n\n::: callout-tip\n### Example\n\nTake the example that we just did in the last section.\n\nThat can be done with the following sequence in a single R expression.\n\n```{r}\nc19_df %>% \n  select(state, age) %>%\n  arrange(age) %>%\n  mutate(age_cat = ifelse(age<20, \"<19\", \n                         ifelse(age>59, \">60\", \"20-59\"))) %>%   \n  group_by(state, age_cat) %>% \n  summarise(age = mean(age, na.rm = TRUE),\n          age_median= median(age, na.rm = TRUE))\n```\n:::\n\nThis way we do not have to create a set of temporary variables along the way or create a massive nested sequence of function calls.\n\n### `slice_*()`\n\nThe `slice_sample()` function of the `dplyr` package will allow you to see a **sample of random rows** in random order.\n\nThe number of rows to show is specified by the `n` argument.\n\n-   This can be useful if you **do not want to print the entire tibble**, but you want to get a greater sense of the values.\n-   This is a **good option for data analysis reports**, where printing the entire tibble would not be appropriate if the tibble is quite large.\n\n::: callout-tip\n### Example\n\n```{r}\nslice_sample(c19_df, n = 10)\n```\n:::\n\nYou can also use `slice_head()` or `slice_tail()` to take a look at the top rows or bottom rows of your tibble. Again the number of rows can be specified with the `n` argument.\n\nThis will show the first 5 rows.\n\n```{r}\nslice_head(c19_df, n = 5)\n```\n\nThis will show the last 5 rows.\n\n```{r}\nslice_tail(c19_df, n = 5)\n```\n\n## Pivoting in R\n\nThe `tidyr` package includes functions to transfer a data frame between *long* and *wide*.\n\n-   **Wide format** data tends to have different attributes or variables describing an observation placed in separate columns.\n-   **Long format** data tends to have different attributes encoded as levels of a single variable, followed by another column that contains values of the observation at those different levels.\n\nLets create a sample set based on the deaths dataset focussing only on `brand2` uptake over time.\n\n```{r, include=FALSE}\nc19_df <- read.csv(\"https://raw.githubusercontent.com/MoH-Malaysia/covid19-public/main/epidemic/linelist/linelist_deaths.csv\")\n```\n\n```{r, echo=FALSE}\ndose2_df <- c19_df %>% select(date, brand2) %>%\n  mutate(across(where(is.character), na_if, \"\"),\n         brand2=ifelse(is.na(brand2), \"unvaccinated\", brand2)) %>%\n  group_by(date, brand2) %>%\n  summarise(count=n()) \n```\n\n### `pivot_wider()`\n\nThe `pivot_wider()` function is less commonly needed to tidy data as compared to its sister `pivot_longer`. It can, however, be useful for creating summary tables. As out sample dataset is already in long form- for the sake of this example we will `pivot_wider` first.\n\n```{r}\ndose2_df <- dose2_df %>%\n  pivot_wider(id_cols=\"date\",\n              names_from = \"brand2\",\n              values_from = \"count\")\n```\n\n::: callout-tip\n### Tippy-tip\n\nYou use the `kable()` function in `dplyr` to make nicer looking html tables\n\n```{r}\ndose2_df %>%\n  mutate_all(~replace_na(., 0)) %>%\n  head(10) %>%\n  knitr::kable(format=\"html\", caption = \"Vaccinations among COVID-19 fatalities by Brand\") %>% kableExtra::kable_minimal()\n```\n:::\n\n### `pivot_longer()`\n\nEven if your data is in a tidy format, `pivot_longer()` is useful for pulling data together to take advantage of faceting, or plotting separate plots based on a grouping variable.\n\n```{r}\ndose2_df %>%\n  pivot_longer(-date, \n               names_to = \"brand2\",\n               values_to = \"count\")\n```\n\n### `separate()` and `unite()`\n\nThe same `tidyr` package also contains two useful functions:\n\n-   `unite()`: combine contents of two or more columns into a single column\n-   `separate()`: separate contents of a column into two or more columns\n\nFirst, we combine the first three columns into one new column using `unite()`.\n\n```{r}\nc19_df %>% select(brand1, brand2, brand3) %>%\n  unite(col=\"profile\", \n        brand1:brand3, \n        sep=\"_\") %>%\n  tail(10)\n```\n\nNext, we show how to separate the columns into three separate columns using `separate()` using the `col`, `into` and `sep` arguments.\n\n```{r}\nc19_df %>% select(brand1, brand2, brand3) %>%\n  unite(col=\"profile\", \n        brand1:brand3, \n        sep=\"_\") %>% \n  select(profile) %>%\n  separate(col=\"profile\", \n           into=c(\"brand1\", \"brand2\", \"brand3\"), \n           sep=\"_\") %>% \n  tail(10)\n```\n\n## Mutating joins\n\nThe `dplyr` package provides a set of **functions for joining two data frames** into a single data frame based on a set of key columns.\n\nThere are several functions in the `*_join()` family.\n\n-   These functions all merge together two data frames\n-   They differ in how they handle observations that exist in one but not both data frames.\n\nHere, are the **four functions from this family** that you will likely use the most often:\n\n```{r, echo=FALSE}\n#| echo: false\n#| out-width: '60%'\n#| fig-align: 'center'\nlibrary(knitr)\njoin_funcs <- data.frame(func = c(\"`left_join()`\",\n                                  \"`right_join()`\",\n                                  \"`inner_join()`\",\n                                  \"`full_join()`\"),\n                         does = c(\"Includes all observations in the left data frame, whether or not there is a match in the right data frame\",\n                                  \"Includes all observations in the right data frame, whether or not there is a match in the left data frame\",\n                                  \"Includes only observations that are in both data frames\",\n                                  \"Includes all observations from both data frames\"))\nknitr::kable(join_funcs, col.names = c(\"Function\", \"What it includes in merged data frame\"))\n```\n\n![](https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png)\n\n\\[[Source from R for Data Science](https://r4ds.had.co.nz/relational-data#relational-data)\\]\n\nSuppose we want to create a table that combines the information about COVID-19 deaths (`c19_df`) with the information about the expenditure (`hies_df`) at each state.\n\nFirst lets take c19_df and aggregate it at the state level.\n\n```{r}\nstate_df <- c19_df %>% select(state) %>%\n  group_by(state) %>%\n  summarise(deaths=n())\n```\n\nLets call in an external object to join\n\n```{r}\nhies_df <- read.csv(\"https://raw.githubusercontent.com/dosm-malaysia/data-open/main/datasets/economy/hies_2019.csv\")\n```\n\nLets look at the data\n\n```{r}\ntable(hies_df$area_type)\n```\n\n### Left Join\n\nWe can use the `left_join()` function to merge the `state_df` and `hies_df` datasets.\n\n```{r leftjoin}\nleft_join(x = state_df, y = hies_df, by = join_by(state==area))\n```\n\n::: callout-tip\n### Note\n\nThe `by` argument indicates the column (or columns) that the two tables have in common. One more than one joining variable an be used for this statement\n:::\n\nQuite obviously the join should give you the total number of rows on the left side of your statement. Note in the above case there are 20 rows because there are four districts with the same name as states.\n\n### Inner Join\n\nThe `inner_join()` function only **retains the rows of both tables** that have corresponding values. Here we can see the difference.\n\n```{r}\ninner_join(x = state_df, y = hies_df, by = join_by(state==area))\n```\n\nDoes `inner_join` give different results to `left_join` in the above example?\n\n### Right Join\n\nThe `right_join()` function is like the `left_join()` function except that it **gives priority to the \"right\" hand argument**.\n\n```{r}\nright_join(x = state_df, y = hies_df, by = join_by(state==area))\n```\n\nWhat about now?\n\n![](/images/normal.png)\n\n## Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://stephaniehicks.com/jhustatcomputing2022/>\n\n-   [The Epidemiologist R Handbook](https://epirhandbook.com/en/index.html)\n\n-   <https://rafalab.github.io/dsbook>\n\n-   <https://rmd4sci.njtierney.com>\n\n## Additional Resources\n\n::: callout-tip\n-   <https://r4ds.had.co.nz/tibbles.html>\n-   <https://jhudatascience.org/tidyversecourse/wrangle-data.html#data-wrangling>\n-   [dplyr cheat sheet from RStudio](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)\n:::\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"session1_wranggling.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.189","editor":"visual","theme":"materia","title":"Introduction to the Tidyverse for Data wrangling","author":"Vivek Jason","toc_float":true},"extensions":{"book":{"multiFile":true}}}}}