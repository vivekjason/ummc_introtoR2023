{
  "hash": "1d178b9aaf174f275eb5979867baa6f4",
  "result": {
    "markdown": "---\ntitle: \"Introduction to the Tidyverse for Data wrangling\"\nauthor: \"Vivek Jason\"\nformat: \n  html:\n    theme: materia\n    toc: true\n    toc_float: true\neditor: visual\n---\n\n\nData cleaning is arguably the most crucial step in the data analysis pipeline because it directly impacts the accuracy and reliability of insights drawn from the data.\n\n## Garbage in, garbage out, as the saying goes.\n\nWithout thoroughly cleaning the data, we might be working with incorrect, inconsistent, or irrelevant information, leading to potentially faulty conclusions. Data cleaning ensures the data is correctly formatted, accurate, complete, and ready for analysis. It involves dealing with missing values, removing duplicates, correcting inconsistencies, and handling outliers. Only after a rigorous data cleaning process can we trust that our analysis or model will give us meaningful, actionable insights.\n\nThus, while it can be a time-consuming process, skipping or skimping on data cleaning can lead to wasting even more time and resources downstream, as we try to interpret misleading results or troubleshoot models that aren't performing as expected.\n\n![](/images/1_Xhm9c9qDfXa3ZCQjiOvm_w.jpg){fig-align=\"center\"}\n\n### RStudio environment\n\n![](/images/rstudio.png){fig-align=\"center\"}\n\n### Setting a working directory\n\nCheck you working directory by\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n:::\n\n\nYou can then set your working directory like this\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"C:\\Users\\VivekJason\\RTraining\\introduction\")\n```\n:::\n\n\n::: callout-warning\n## Setting a work directory like this is called an absolute path and in statistical computing is a frowned upon practice as it locks directories to you system only. Instead we should utilise relative paths.\n:::\n\nA relative path should look like this\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"../data\")\n```\n:::\n\n\nThere are even better practices for sustainability and reproducibility such but we wont cover those practices here. You can find more information in this [post](https://www.tidyverse.org/articles/2017/12/workflow-vs-script/)\n\n### Reading data into R\n\nThis section demonstrates the fundamental functions required to read and write data in R.\n\nIn base R, there are key functions for reading data:\n\n-   read.table() & read.csv(): used for reading tabular data\n\n-   readLines(): used for reading lines from a text file\n\nCorresponding functions exist for writing data:\n\n-   write.table(): used to write tabular data to text files or connections, such as CSV\n\n-   writeLines(): used to write character data line-by-line to a file or connection\n\nLet's attempt to read data into R using the read.csv() function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(\"data/yourfilename.csv\")#this is just an example\n```\n:::\n\n\nYou can even pull a csv straight from the web\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(\"https://raw.githubusercontent.com/MoH-Malaysia/data-darah-public/main/newdonors_state.csv\")\n```\n:::\n\n\nYou can export he above csv to you computer by\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(df, \"blood_donor_malaysia.csv\")\n```\n:::\n\n\n### Packages and loading them\n\nIn the olden days you would install the package and call them into you environment like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n:::\n\n\nBut these days we have packages that deal with even that\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(\n     tidyverse\n)\n```\n:::\n\n\n# The \"Tidyverse\"\n\nThere are a number of R packages that take advantage of the tidy data form and can be used to do interesting things with data. Many (but not all) of these packages are written by Hadley Wickham and **the collection of packages is often referred to as the \"tidyverse\"** because of their **dependence on and presumption of tidy data**.\n\nA subset of the \"Tidyverse\" packages include:\n\n-   [ggplot2](https://cran.r-project.org/package=ggplot2): a plotting system based on the grammar of graphics\n\n-   [magrittr](https://cran.r-project.org/package=magrittr%22): defines the `%>%` operator for chaining functions together in a series of operations on data\n\n-   [dplyr](https://cran.r-project.org/package=dplyr): a suite of (fast) functions for working with data frames\n\n-   [tidyr](https://cran.r-project.org/package=tidyr): easily tidy data with `pivot_wider()` and `pivot_longer()` functions (also `separate()` and `unite()`)\n\nA complete list can be found here (<https://www.tidyverse.org/packages>).\n\nWe can call in the tidyverse as mentioned in the introduction like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## Data Frames\n\nThe **data frame** (or `data.frame`) is a **key data structure** in statistics and in R.\n\nThe basic structure of a data frame is that there is **one observation per row and each column represents a variable, a measure, feature, or characteristic of that observation**.\n\n### Calling in some data\n\nFor the purposes of this session lets utilise the Malaysian COVID-19 deaths linelists maintained by the Ministry of Health on their [Github page](https://github.com/MoH-Malaysia). Codes for each column are as follows:\n\n1.  `date`: yyyy-mm-dd format; date of death\n\n2.  `date_announced`: date on which the death was announced to the public (i.e. registered in the public linelist)\n\n3.  `date_positive`: date of positive sample\n\n4.  `date_doseN`: date of the individual's first/second/third dose (if any)\n\n5.  `brandN`: `p` = Pfizer, `s` = Sinovac, `a` = AstraZeneca, `c` = Cansino, `m` = Moderna, `h` = Sinopharm, `j` = Janssen, `u` = unverified (pending sync with VMS)\n\n6.  `state`: state of residence\n\n7.  `age`: age as an integer; note that it is possible for age to be 0, denoting infants less than 6 months old\n\n8.  `male`: binary variable with 1 denoting male and 0 denoting female\n\n9.  `bid`: binary variable with 1 denoting brought-in-dead and 0 denoting an inpatient death\n\n10. `malaysian`: binary variable with 1 denoting Malaysian and 0 denoting non-Malaysian\n\n11. `comorb`: binary variable with 1 denoting that the individual has comorbidities and 0 denoting no comorbidities declared\n\nLets call in the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df <- read.csv(\"https://raw.githubusercontent.com/MoH-Malaysia/covid19-public/main/epidemic/linelist/linelist_deaths.csv\")\n```\n:::\n\n\nCheck the data structure\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(c19_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t37165 obs. of  15 variables:\n $ date          : chr  \"2020-03-17\" \"2020-03-17\" \"2020-03-20\" \"2020-03-21\" ...\n $ date_announced: chr  \"2020-03-17\" \"2020-03-17\" \"2020-03-20\" \"2020-03-21\" ...\n $ date_positive : chr  \"2020-03-12\" \"2020-03-15\" \"2020-03-11\" \"2020-03-13\" ...\n $ date_dose1    : chr  \"\" \"\" \"\" \"\" ...\n $ date_dose2    : chr  \"\" \"\" \"\" \"\" ...\n $ date_dose3    : chr  \"\" \"\" \"\" \"\" ...\n $ brand1        : chr  \"\" \"\" \"\" \"\" ...\n $ brand2        : chr  \"\" \"\" \"\" \"\" ...\n $ brand3        : chr  \"\" \"\" \"\" \"\" ...\n $ state         : chr  \"Johor\" \"Sarawak\" \"Sabah\" \"Melaka\" ...\n $ age           : int  34 60 58 50 80 39 57 69 48 73 ...\n $ male          : int  1 1 1 1 0 0 1 1 1 1 ...\n $ bid           : int  0 0 0 0 1 0 0 0 0 0 ...\n $ malaysian     : int  1 1 1 1 1 1 1 1 1 1 ...\n $ comorb        : int  1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n\n```{.r .cell-code}\ndim(c19_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 37165    15\n```\n:::\n:::\n\n\n# The `dplyr` Package\n\nThe `dplyr` package was developed by Posit (formely RStudio) and is **an optimized and distilled** version of the older `plyr` **package for data manipulation or wrangling**.\n\n![Artwork by Allison Horst on the dplyr package](https://github.com/allisonhorst/stats-illustrations/raw/main/rstats-artwork/dplyr_wrangling.png){alt=\"Artwork by Allison Horst on the dplyr package\" width=\"80%\"}\n\n\\[**Source**: [Artwork by Allison Horst](https://github.com/allisonhorst/stats-illustrations)\\]\n\nThe `dplyr` package does not provide any \"new\" functionality to R per se, in the sense that everything `dplyr` does could already be done with base R, but it **greatly** simplifies existing functionality in R.\n\nOne important contribution of the `dplyr` package is that it **provides a \"grammar\" (in particular, verbs) for data manipulation and for operating on data frames**.\n\nWith this grammar, you can sensibly communicate what it is that you are doing to a data frame that other people can understand (assuming they also know the grammar). This is useful because it **provides an abstraction for data manipulation that previously did not exist**.\n\nAnother useful contribution is that the `dplyr` functions are **very** fast, as many key operations are coded in C++.\n\n### `dplyr` grammar\n\nSome of the key \"verbs\" provided by the `dplyr` package are\n\n-   `select()`: return a subset of the columns of a data frame, using a flexible notation\n\n-   `filter()`: extract a subset of rows from a data frame based on logical conditions\n\n-   `arrange()`: reorder rows of a data frame\n\n-   `rename()`: rename variables in a data frame\n\n-   `mutate()`: add new variables/columns or transform existing variables\n\n-   `summarise()` / `summarize()`: generate summary statistics of different variables in the data frame, possibly within strata\n\n-   `%>%`: the \"pipe\" operator is used to connect multiple verb actions together into a pipelineArtwork by\n\n### `select()`\n\nLets convert the COVID-19 deaths linelist into a tibble first\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df <- as_tibble(c19_df)\nstr(c19_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [37,165 × 15] (S3: tbl_df/tbl/data.frame)\n $ date          : chr [1:37165] \"2020-03-17\" \"2020-03-17\" \"2020-03-20\" \"2020-03-21\" ...\n $ date_announced: chr [1:37165] \"2020-03-17\" \"2020-03-17\" \"2020-03-20\" \"2020-03-21\" ...\n $ date_positive : chr [1:37165] \"2020-03-12\" \"2020-03-15\" \"2020-03-11\" \"2020-03-13\" ...\n $ date_dose1    : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ date_dose2    : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ date_dose3    : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ brand1        : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ brand2        : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ brand3        : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ state         : chr [1:37165] \"Johor\" \"Sarawak\" \"Sabah\" \"Melaka\" ...\n $ age           : int [1:37165] 34 60 58 50 80 39 57 69 48 73 ...\n $ male          : int [1:37165] 1 1 1 1 0 0 1 1 1 1 ...\n $ bid           : int [1:37165] 0 0 0 0 1 0 0 0 0 0 ...\n $ malaysian     : int [1:37165] 1 1 1 1 1 1 1 1 1 1 ...\n $ comorb        : int [1:37165] 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n:::\n\n\nThe `select()` function can be used to **select columns of a data frame** that you want to focus on.\n\n::: callout-tip\n### Example\n\nSuppose we wanted to take the last 5 columns only. There are a few ways to do this.\n\nWe could for example use numerical indices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(c19_df)[10:15]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"state\"     \"age\"       \"male\"      \"bid\"       \"malaysian\" \"comorb\"   \n```\n:::\n:::\n\n\nBut we can also use the names directly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset <- select(c19_df, state:comorb)\nhead(subset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  state     age  male   bid malaysian comorb\n  <chr>   <int> <int> <int>     <int>  <int>\n1 Johor      34     1     0         1      1\n2 Sarawak    60     1     0         1      1\n3 Sabah      58     1     0         1      1\n4 Melaka     50     1     0         1      1\n5 Sarawak    80     0     1         1      1\n6 Sarawak    39     0     0         1      1\n```\n:::\n:::\n\n:::\n\n::: callout-tip\n### Note\n\nThe `:` normally cannot be used with names or strings, but inside the `select()` function you can use it to specify a range of variable names.\n:::\n\nYou can also **omit** variables using the `select()` function by using the negative sign. With `select()` you can do\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(c19_df, -(state:comorb))\n```\n:::\n\n\nThe `select()` function also allows a special syntax that allows you to specify variable names based on patterns. So, for example, if you wanted to keep every variable that ends with a \"2\", we could do\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset <- select(c19_df, ends_with(c(\"1\", \"2\", \"3\")))\nstr(subset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [37,165 × 6] (S3: tbl_df/tbl/data.frame)\n $ date_dose1: chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ brand1    : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ date_dose2: chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ brand2    : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ date_dose3: chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ brand3    : chr [1:37165] \"\" \"\" \"\" \"\" ...\n```\n:::\n:::\n\n\nOr if we wanted to keep every variable that starts with a \"date\", we could do\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset <- select(c19_df, contains(\"date\"))\nstr(subset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [37,165 × 6] (S3: tbl_df/tbl/data.frame)\n $ date          : chr [1:37165] \"2020-03-17\" \"2020-03-17\" \"2020-03-20\" \"2020-03-21\" ...\n $ date_announced: chr [1:37165] \"2020-03-17\" \"2020-03-17\" \"2020-03-20\" \"2020-03-21\" ...\n $ date_positive : chr [1:37165] \"2020-03-12\" \"2020-03-15\" \"2020-03-11\" \"2020-03-13\" ...\n $ date_dose1    : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ date_dose2    : chr [1:37165] \"\" \"\" \"\" \"\" ...\n $ date_dose3    : chr [1:37165] \"\" \"\" \"\" \"\" ...\n```\n:::\n:::\n\n\nYou can also use more general regular expressions if necessary. See the help page (`?select`) for more details.\n\n### `filter()`\n\nThe `filter()` function is used to **extract subsets of rows** from a data frame. This function is similar to the existing `subset()` function in R but is quite a bit faster in my experience.\n\n![Artwork by Allison Horst on filter() function](https://github.com/allisonhorst/stats-illustrations/raw/main/rstats-artwork/dplyr_filter.jpg){alt=\"Artwork by Allison Horst on filter() function\" width=\"80%\"}\n\n\\[**Source**: [Artwork by Allison Horst](https://github.com/allisonhorst/stats-illustrations)\\]\n\n::: callout-tip\n### Example\n\nSuppose we wanted to extract the rows of the `c19_df` data frame of deaths in individuals older than 60, we could do\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_filter <- filter(c19_df, age > 59)\nstr(c19_filter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [22,288 × 15] (S3: tbl_df/tbl/data.frame)\n $ date          : chr [1:22288] \"2020-03-17\" \"2020-03-22\" \"2020-03-21\" \"2020-03-22\" ...\n $ date_announced: chr [1:22288] \"2020-03-17\" \"2020-03-22\" \"2020-03-21\" \"2020-03-22\" ...\n $ date_positive : chr [1:22288] \"2020-03-15\" \"2020-03-20\" \"2020-03-17\" \"2020-03-14\" ...\n $ date_dose1    : chr [1:22288] \"\" \"\" \"\" \"\" ...\n $ date_dose2    : chr [1:22288] \"\" \"\" \"\" \"\" ...\n $ date_dose3    : chr [1:22288] \"\" \"\" \"\" \"\" ...\n $ brand1        : chr [1:22288] \"\" \"\" \"\" \"\" ...\n $ brand2        : chr [1:22288] \"\" \"\" \"\" \"\" ...\n $ brand3        : chr [1:22288] \"\" \"\" \"\" \"\" ...\n $ state         : chr [1:22288] \"Sarawak\" \"Sarawak\" \"Kelantan\" \"Pulau Pinang\" ...\n $ age           : int [1:22288] 60 80 69 73 70 70 70 75 66 68 ...\n $ male          : int [1:22288] 1 0 1 1 1 1 1 1 1 0 ...\n $ bid           : int [1:22288] 0 1 0 0 0 0 0 0 0 0 ...\n $ malaysian     : int [1:22288] 1 1 1 1 1 1 1 1 1 1 ...\n $ comorb        : int [1:22288] 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n:::\n\n:::\n\nYou can see that there are now only 22288 rows in the data frame and the distribution of the `age` values is.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(c19_filter$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   60.0    66.0    73.0    73.7    81.0   130.0 \n```\n:::\n:::\n\n\nWe can place an arbitrarily complex logical sequence inside of `filter()`, so we could for example extract the rows where age is greater than 60 and nationality (`malaysian`) is equal to 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_filter <- filter(c19_df, age < 21 & malaysian==1)\nselect(c19_filter, date, malaysian, age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 221 × 3\n   date       malaysian   age\n   <chr>          <int> <int>\n 1 2020-10-05         1     1\n 2 2020-11-08         1     2\n 3 2020-11-15         1     8\n 4 2020-11-04         1    15\n 5 2021-02-03         1     0\n 6 2021-01-21         1    18\n 7 2021-02-09         1    20\n 8 2021-02-13         1     9\n 9 2021-05-10         1    17\n10 2021-04-04         1     3\n# ℹ 211 more rows\n```\n:::\n:::\n\n\nNow there are only 221 observations where both of those conditions are met.\n\nOther logical operators you should be aware of include:\n\n|  Operator |                  Meaning |                             Example |\n|----------:|-------------------------:|------------------------------------:|\n|      `==` |                   Equals |                     `malaysian== 1` |\n|      `!=` |           Does not equal |                     `malaysian!= 1` |\n|       `>` |             Greater than |                           `age> 60` |\n|      `>=` | Greater than or equal to |                          `age>= 60` |\n|       `<` |                Less than |                           `age< 60` |\n|      `<=` |    Less than or equal to |                          `age<= 60` |\n|    `%in%` |              Included in | `state %in% c(\"Selangor\", \"Johor\")` |\n| `is.na()` |       Is a missing value |                `is.na(date_dose_2)` |\n\n::: callout-tip\n### Note\n\nIf you are ever unsure of how to write a logical statement, but know how to write its opposite, you can use the `!` operator to negate the whole statement.\n\nA common use of this is to identify observations with non-missing data (e.g., `!(is.na(date_dose_2))`).\n:::\n\n### `arrange()`\n\nThe `arrange()` function is used to **reorder rows** of a data frame according to one of the variables/columns. Reordering rows of a data frame (while preserving corresponding order of other columns) is normally a pain to do in R. The `arrange()` function simplifies the process quite a bit.\n\nHere we can order the rows of the data frame by date, so that the first row is the earliest (oldest) observation and the last row is the latest (most recent) observation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df <- arrange(c19_df, date)\n```\n:::\n\n\nWe can now check the first few rows\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(select(c19_df, date, age), 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  date         age\n  <chr>      <int>\n1 2020-03-17    34\n2 2020-03-17    60\n3 2020-03-20    58\n```\n:::\n:::\n\n\nColumns can be arranged in descending order too by useing the special `desc()` operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df <- arrange(c19_df, desc(date))\n```\n:::\n\n\nLooking at the first three and last three rows shows the dates in descending order.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(select(c19_df, date, age), 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  date         age\n  <chr>      <int>\n1 2023-07-30    77\n2 2023-07-20    60\n3 2023-07-19    88\n```\n:::\n\n```{.r .cell-code}\ntail(select(c19_df, date, age), 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  date         age\n  <chr>      <int>\n1 2020-03-20    58\n2 2020-03-17    34\n3 2020-03-17    60\n```\n:::\n:::\n\n\n### `rename()`\n\n**Renaming a variable** in a data frame in R is surprisingly hard to do! The `rename()` function is designed to make this process easier.\n\nHere you can see the names of the first six variables in the `c19_df` data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(c19_df[, 1:6], 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  date       date_announced date_positive date_dose1   date_dose2   date_dose3  \n  <chr>      <chr>          <chr>         <chr>        <chr>        <chr>       \n1 2023-07-30 2023-08-04     2023-07-30    \"\"           \"\"           \"\"          \n2 2023-07-20 2023-07-24     2023-07-15    \"2021-08-12\" \"2021-09-02\" \"2022-01-13\"\n3 2023-07-19 2023-07-22     2023-07-19    \"2021-05-03\" \"2021-05-24\" \"2022-02-09\"\n```\n:::\n:::\n\n\nThese names are (arbitrarily again) unnecessarily long. Date doesn't need to be repeated for each column name are no other columns that could potentially be confused with the first six. So we can modify cause we're lazy to type long column names when analysing later on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df <- rename(c19_df, death = date,\n                 announced = date_announced,\n                 positive = date_positive,\n                 dose1 = date_dose1,\n                 dose2 = date_dose2,\n                 dose3 = date_dose3)\nhead(c19_df[, 1:5], 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n  death      announced  positive   dose1        dose2       \n  <chr>      <chr>      <chr>      <chr>        <chr>       \n1 2023-07-30 2023-08-04 2023-07-30 \"\"           \"\"          \n2 2023-07-20 2023-07-24 2023-07-15 \"2021-08-12\" \"2021-09-02\"\n3 2023-07-19 2023-07-22 2023-07-19 \"2021-05-03\" \"2021-05-24\"\n```\n:::\n:::\n\n\nThe syntax inside the `rename()` function is to have the new name on the left-hand side of the `=` sign and the old name on the right-hand side.\n\n### `mutate()`\n\nThe `mutate()` function exists to **compute transformations of variables** in a data frame. Often, you want to create new variables that are derived from existing variables and `mutate()` provides a clean interface for doing that.\n\n![Artwork by Allison Horst on mutate() function](https://github.com/allisonhorst/stats-illustrations/raw/main/rstats-artwork/dplyr_mutate.png){alt=\"Artwork by Allison Horst on mutate() function\" width=\"80%\"}\n\n\\[**Source**: [Artwork by Allison Horst](https://github.com/allisonhorst/stats-illustrations)\\]\n\nFor example, with demographic data, we often want to *categorise data*\n\nHere, we create a `age_cat` variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df <- mutate(c19_df, age_cat= ifelse(age<20, \"<19\", \n                                         ifelse(age>59, \">60\", \"20-59\")))\n```\n:::\n\n\nwe can also `recode` category values within a variable, such as\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df <- mutate(c19_df,  brand2 = recode(brand2, \n                          \"Pfizer\" = 0, \n                          \"Sinovac\" = 1, \n                          \"AstraZeneca\" = 2, \n                          \"Moderna\" = 2, \n                          \"Pending VMS sync\" = 2, \n                          \"Sinopharm\" = 2))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `brand2 = recode(...)`.\nCaused by warning:\n! Unreplaced values treated as NA as `.x` is not compatible.\nPlease specify replacements exhaustively or supply `.default`.\n```\n:::\n:::\n\n\n### `group_by()`\n\nThe `group_by()` function is used to **generate summary statistics** from the data frame within strata defined by a variable.\n\nFor example, in this dataset, you might want to know what the number of deaths in each state is?\n\n**In conjunction** with the `group_by()` function, we often use the `summarise()` function\n\n::: callout-tip\n### Note\n\nThe **general operation** here is a combination of\n\n1.  Splitting a data frame into separate pieces defined by a variable or group of variables (`group_by()`)\n2.  Then, applying a summary function across those subsets (`summarise()`)\n:::\n\n::: callout-tip\n### Example\n\nWe can create a separate data frame that splits the original data frame by state\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstate <- group_by(c19_df, state)\n```\n:::\n\n\nWe can then compute summary statistics for each year in the data frame with the `summarise()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(state, age = mean(age, na.rm = TRUE),\n          age_median= median(age, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 3\n   state               age age_median\n   <chr>             <dbl>      <dbl>\n 1 Johor              60.9       60.9\n 2 Kedah              63.1       63.1\n 3 Kelantan           66.7       66.7\n 4 Melaka             62.2       62.2\n 5 Negeri Sembilan    64.5       64.5\n 6 Pahang             63.2       63.2\n 7 Perak              67.0       67.0\n 8 Perlis             68.1       68.1\n 9 Pulau Pinang       66.0       66.0\n10 Sabah              65.4       65.4\n11 Sarawak            68.1       68.1\n12 Selangor           59.4       59.4\n13 Terengganu         64.9       64.9\n14 W.P. Kuala Lumpur  61.7       61.7\n15 W.P. Labuan        59.3       59.3\n16 W.P. Putrajaya     64.7       64.7\n```\n:::\n:::\n\n:::\n\n### `%>%`\n\nThe pipeline operator `%>%` is very handy for **stringing together multiple `dplyr` functions in a sequence of operations**.\n\nNotice above that every time we wanted to apply more than one function, the sequence gets buried in a sequence of nested function calls that is difficult to read, i.e. This **nesting is not a natural way** to think about a sequence of operations.\n\nThe `%>%` operator allows you to string operations in a left-to-right fashion, i.e\n\n::: callout-tip\n### Example\n\nTake the example that we just did in the last section.\n\nThat can be done with the following sequence in a single R expression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df %>% \n  select(state, age) %>%\n  arrange(age) %>%\n  mutate(age_cat = ifelse(age<20, \"<19\", \n                         ifelse(age>59, \">60\", \"20-59\"))) %>%   \n  group_by(state, age_cat) %>% \n  summarise(age = mean(age, na.rm = TRUE),\n          age_median= median(age, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 46 × 4\n# Groups:   state [16]\n   state    age_cat   age age_median\n   <chr>    <chr>   <dbl>      <dbl>\n 1 Johor    20-59   45.8       45.8 \n 2 Johor    <19      8.62       8.62\n 3 Johor    >60     73.5       73.5 \n 4 Kedah    20-59   46.9       46.9 \n 5 Kedah    <19      7.47       7.47\n 6 Kedah    >60     73.7       73.7 \n 7 Kelantan 20-59   47.7       47.7 \n 8 Kelantan <19     14.4       14.4 \n 9 Kelantan >60     74.1       74.1 \n10 Melaka   20-59   46.0       46.0 \n# ℹ 36 more rows\n```\n:::\n:::\n\n:::\n\nThis way we do not have to create a set of temporary variables along the way or create a massive nested sequence of function calls.\n\n### `slice_*()`\n\nThe `slice_sample()` function of the `dplyr` package will allow you to see a **sample of random rows** in random order.\n\nThe number of rows to show is specified by the `n` argument.\n\n-   This can be useful if you **do not want to print the entire tibble**, but you want to get a greater sense of the values.\n-   This is a **good option for data analysis reports**, where printing the entire tibble would not be appropriate if the tibble is quite large.\n\n::: callout-tip\n### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice_sample(c19_df, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 16\n   death   announced positive dose1 dose2 dose3 brand1 brand2 brand3 state   age\n   <chr>   <chr>     <chr>    <chr> <chr> <chr> <chr>   <dbl> <chr>  <chr> <int>\n 1 2022-0… 2022-03-… 2022-03… \"\"    \"\"    \"\"    \"\"         NA \"\"     Perak    63\n 2 2022-0… 2022-03-… 2022-02… \"202… \"202… \"\"    \"Sino…      1 \"\"     Sela…    81\n 3 2021-0… 2021-06-… 2021-06… \"\"    \"\"    \"\"    \"\"         NA \"\"     Sela…    74\n 4 2021-1… 2021-11-… 2021-10… \"202… \"\"    \"\"    \"Pfiz…     NA \"\"     Johor    24\n 5 2022-0… 2022-02-… 2022-02… \"202… \"202… \"\"    \"Sino…      1 \"\"     Sela…    48\n 6 2021-0… 2021-08-… 2021-07… \"\"    \"\"    \"\"    \"\"         NA \"\"     Perak    67\n 7 2021-0… 2021-09-… 2021-07… \"202… \"\"    \"\"    \"Sino…     NA \"\"     Sela…    52\n 8 2021-0… 2021-09-… 2021-08… \"202… \"202… \"\"    \"Sino…      1 \"\"     Kedah    83\n 9 2021-0… 2021-07-… 2021-07… \"202… \"\"    \"\"    \"Sino…     NA \"\"     Paha…    48\n10 2021-0… 2021-08-… 2021-07… \"\"    \"\"    \"\"    \"\"         NA \"\"     Sela…    39\n# ℹ 5 more variables: male <int>, bid <int>, malaysian <int>, comorb <int>,\n#   age_cat <chr>\n```\n:::\n:::\n\n:::\n\nYou can also use `slice_head()` or `slice_tail()` to take a look at the top rows or bottom rows of your tibble. Again the number of rows can be specified with the `n` argument.\n\nThis will show the first 5 rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice_head(c19_df, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 16\n  death    announced positive dose1 dose2 dose3 brand1 brand2 brand3 state   age\n  <chr>    <chr>     <chr>    <chr> <chr> <chr> <chr>   <dbl> <chr>  <chr> <int>\n1 2023-07… 2023-08-… 2023-07… \"\"    \"\"    \"\"    \"\"         NA \"\"     Mela…    77\n2 2023-07… 2023-07-… 2023-07… \"202… \"202… \"202… \"Pfiz…      0 \"Pfiz… Sela…    60\n3 2023-07… 2023-07-… 2023-07… \"202… \"202… \"202… \"Pfiz…      0 \"Pfiz… Perak    88\n4 2023-07… 2023-07-… 2023-07… \"202… \"202… \"\"    \"Pfiz…      0 \"\"     Sabah    84\n5 2023-07… 2023-07-… 2023-07… \"202… \"202… \"202… \"Sino…      1 \"Sino… Perak    75\n# ℹ 5 more variables: male <int>, bid <int>, malaysian <int>, comorb <int>,\n#   age_cat <chr>\n```\n:::\n:::\n\n\nThis will show the last 5 rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice_tail(c19_df, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 16\n  death    announced positive dose1 dose2 dose3 brand1 brand2 brand3 state   age\n  <chr>    <chr>     <chr>    <chr> <chr> <chr> <chr>   <dbl> <chr>  <chr> <int>\n1 2020-03… 2020-03-… 2020-03… \"\"    \"\"    \"\"    \"\"         NA \"\"     W.P.…    57\n2 2020-03… 2020-03-… 2020-03… \"\"    \"\"    \"\"    \"\"         NA \"\"     Kela…    69\n3 2020-03… 2020-03-… 2020-03… \"\"    \"\"    \"\"    \"\"         NA \"\"     Sabah    58\n4 2020-03… 2020-03-… 2020-03… \"\"    \"\"    \"\"    \"\"         NA \"\"     Johor    34\n5 2020-03… 2020-03-… 2020-03… \"\"    \"\"    \"\"    \"\"         NA \"\"     Sara…    60\n# ℹ 5 more variables: male <int>, bid <int>, malaysian <int>, comorb <int>,\n#   age_cat <chr>\n```\n:::\n:::\n\n\n## Pivoting in R\n\nThe `tidyr` package includes functions to transfer a data frame between *long* and *wide*.\n\n-   **Wide format** data tends to have different attributes or variables describing an observation placed in separate columns.\n-   **Long format** data tends to have different attributes encoded as levels of a single variable, followed by another column that contains values of the observation at those different levels.\n\nLets create a sample set based on the deaths dataset focussing only on `brand2` uptake over time.\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(where(is.character), na_if, \"\")`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'date'. You can override using the\n`.groups` argument.\n```\n:::\n:::\n\n\n### `pivot_wider()`\n\nThe `pivot_wider()` function is less commonly needed to tidy data as compared to its sister `pivot_longer`. It can, however, be useful for creating summary tables. As out sample dataset is already in long form- for the sake of this example we will `pivot_wider` first.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndose2_df <- dose2_df %>%\n  pivot_wider(id_cols=\"date\",\n              names_from = \"brand2\",\n              values_from = \"count\")\n```\n:::\n\n\n::: callout-tip\n### Tippy-tip\n\nYou use the `kable()` function in `dplyr` to make nicer looking html tables\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndose2_df %>%\n  mutate_all(~replace_na(., 0)) %>%\n  head(10) %>%\n  knitr::kable(format=\"html\", caption = \"Vaccinations among COVID-19 fatalities by Brand\") %>% kableExtra::kable_minimal()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`mutate_all()` ignored the following grouping variables:\n• Column `date`\nℹ Use `mutate_at(df, vars(-group_cols()), myoperation)` to silence the message.\n```\n:::\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-minimal\" style='font-family: \"Trebuchet MS\", verdana, sans-serif; margin-left: auto; margin-right: auto;'>\n<caption>Vaccinations among COVID-19 fatalities by Brand</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> date </th>\n   <th style=\"text-align:right;\"> unvaccinated </th>\n   <th style=\"text-align:right;\"> Pfizer </th>\n   <th style=\"text-align:right;\"> Sinovac </th>\n   <th style=\"text-align:right;\"> Pending VMS sync </th>\n   <th style=\"text-align:right;\"> AstraZeneca </th>\n   <th style=\"text-align:right;\"> Moderna </th>\n   <th style=\"text-align:right;\"> Sinopharm </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-17 </td>\n   <td style=\"text-align:right;\"> 2 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-20 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-21 </td>\n   <td style=\"text-align:right;\"> 4 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-22 </td>\n   <td style=\"text-align:right;\"> 4 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-23 </td>\n   <td style=\"text-align:right;\"> 5 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-24 </td>\n   <td style=\"text-align:right;\"> 2 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-25 </td>\n   <td style=\"text-align:right;\"> 3 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-26 </td>\n   <td style=\"text-align:right;\"> 5 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-27 </td>\n   <td style=\"text-align:right;\"> 2 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2020-03-28 </td>\n   <td style=\"text-align:right;\"> 6 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n:::\n\n### `pivot_longer()`\n\nEven if your data is in a tidy format, `pivot_longer()` is useful for pulling data together to take advantage of faceting, or plotting separate plots based on a grouping variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndose2_df %>%\n  pivot_longer(-date, \n               names_to = \"brand2\",\n               values_to = \"count\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7,091 × 3\n# Groups:   date [1,013]\n   date       brand2           count\n   <chr>      <chr>            <int>\n 1 2020-03-17 unvaccinated         2\n 2 2020-03-17 Pfizer              NA\n 3 2020-03-17 Sinovac             NA\n 4 2020-03-17 Pending VMS sync    NA\n 5 2020-03-17 AstraZeneca         NA\n 6 2020-03-17 Moderna             NA\n 7 2020-03-17 Sinopharm           NA\n 8 2020-03-20 unvaccinated         1\n 9 2020-03-20 Pfizer              NA\n10 2020-03-20 Sinovac             NA\n# ℹ 7,081 more rows\n```\n:::\n:::\n\n\n### `separate()` and `unite()`\n\nThe same `tidyr` package also contains two useful functions:\n\n-   `unite()`: combine contents of two or more columns into a single column\n-   `separate()`: separate contents of a column into two or more columns\n\nFirst, we combine the first three columns into one new column using `unite()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df %>% select(brand1, brand2, brand3) %>%\n  unite(col=\"profile\", \n        brand1:brand3, \n        sep=\"_\") %>%\n  tail(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      profile\n37156                      __\n37157    Pfizer_Pfizer_Pfizer\n37158 Sinovac_Sinovac_Sinovac\n37159           AstraZeneca__\n37160  Sinovac_Sinovac_Pfizer\n37161          Pfizer_Pfizer_\n37162    Pfizer_Pfizer_Pfizer\n37163    Pfizer_Pfizer_Pfizer\n37164    Pfizer_Pfizer_Pfizer\n37165                      __\n```\n:::\n:::\n\n\nNext, we show how to separate the columns into three separate columns using `separate()` using the `col`, `into` and `sep` arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc19_df %>% select(brand1, brand2, brand3) %>%\n  unite(col=\"profile\", \n        brand1:brand3, \n        sep=\"_\") %>% \n  select(profile) %>%\n  separate(col=\"profile\", \n           into=c(\"brand1\", \"brand2\", \"brand3\"), \n           sep=\"_\") %>% \n  tail(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           brand1  brand2  brand3\n37156                            \n37157      Pfizer  Pfizer  Pfizer\n37158     Sinovac Sinovac Sinovac\n37159 AstraZeneca                \n37160     Sinovac Sinovac  Pfizer\n37161      Pfizer  Pfizer        \n37162      Pfizer  Pfizer  Pfizer\n37163      Pfizer  Pfizer  Pfizer\n37164      Pfizer  Pfizer  Pfizer\n37165                            \n```\n:::\n:::\n\n\n## Mutating joins\n\nThe `dplyr` package provides a set of **functions for joining two data frames** into a single data frame based on a set of key columns.\n\nThere are several functions in the `*_join()` family.\n\n-   These functions all merge together two data frames\n-   They differ in how they handle observations that exist in one but not both data frames.\n\nHere, are the **four functions from this family** that you will likely use the most often:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Function </th>\n   <th style=\"text-align:left;\"> What it includes in merged data frame </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> `left_join()` </td>\n   <td style=\"text-align:left;\"> Includes all observations in the left data frame, whether or not there is a match in the right data frame </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> `right_join()` </td>\n   <td style=\"text-align:left;\"> Includes all observations in the right data frame, whether or not there is a match in the left data frame </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> `inner_join()` </td>\n   <td style=\"text-align:left;\"> Includes only observations that are in both data frames </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> `full_join()` </td>\n   <td style=\"text-align:left;\"> Includes all observations from both data frames </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n![](https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png)\n\n\\[[Source from R for Data Science](https://r4ds.had.co.nz/relational-data#relational-data)\\]\n\nSuppose we want to create a table that combines the information about COVID-19 deaths (`c19_df`) with the information about the expenditure (`hies_df`) at each state.\n\nFirst lets take c19_df and aggregate it at the state level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstate_df <- c19_df %>% select(state) %>%\n  group_by(state) %>%\n  summarise(deaths=n())\n```\n:::\n\n\nLets call in an external object to join\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhies_df <- read.csv(\"https://raw.githubusercontent.com/dosm-malaysia/data-open/main/datasets/economy/hies_2019.csv\")\n```\n:::\n\n\nLets look at the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(hies_df$area_type)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n district       dun parliment     state \n      160       600       222        16 \n```\n:::\n:::\n\n\n### Left Join\n\nWe can use the `left_join()` function to merge the `state_df` and `hies_df` datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(x = state_df, y = hies_df, by = join_by(state==area))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 7\n   state        deaths area_type income_mean expenditure_mean  gini poverty_rate\n   <chr>         <int> <chr>           <int>            <int> <dbl>        <dbl>\n 1 Johor          4741 state            8013             4793 0.366          3.9\n 2 Kedah          2756 state            5522             3359 0.354          8.8\n 3 Kelantan       1428 state            4874             3223 0.378         12.4\n 4 Melaka         1215 state            7741             4955 0.383          3.9\n 5 Negeri Semb…   1546 state            6707             4350 0.391          4.3\n 6 Pahang         1037 state            5667             3652 0.33           4.3\n 7 Perak          2168 state            5645             3564 0.377          7.3\n 8 Perlis          199 state            5476             3468 0.334          3.9\n 9 Perlis          199 district         5476             3468 0.334          3.9\n10 Pulau Pinang   2085 state            7774             4630 0.359          1.9\n11 Sabah          3212 state            5745             2792 0.397         19.5\n12 Sarawak        1796 state            5959             3448 0.387          9  \n13 Selangor      11028 state           10827             5830 0.393          1.2\n14 Terengganu      905 state            6815             4336 0.335          6.1\n15 W.P. Kuala …   2861 state           13257             6913 0.35           0.2\n16 W.P. Kuala …   2861 district        13257             6913 0.35           0.2\n17 W.P. Labuan     159 state            8319             4097 0.333          3.1\n18 W.P. Labuan     159 district         8319             4097 0.333          3.1\n19 W.P. Putraj…     29 state           12840             7980 0.361          0.4\n20 W.P. Putraj…     29 district        12840             7980 0.361          0.4\n```\n:::\n:::\n\n\n::: callout-tip\n### Note\n\nThe `by` argument indicates the column (or columns) that the two tables have in common. One more than one joining variable an be used for this statement\n:::\n\nQuite obviously the join should give you the total number of rows on the left side of your statement. Note in the above case there are 20 rows because there are four districts with the same name as states.\n\n### Inner Join\n\nThe `inner_join()` function only **retains the rows of both tables** that have corresponding values. Here we can see the difference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(x = state_df, y = hies_df, by = join_by(state==area))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 7\n   state        deaths area_type income_mean expenditure_mean  gini poverty_rate\n   <chr>         <int> <chr>           <int>            <int> <dbl>        <dbl>\n 1 Johor          4741 state            8013             4793 0.366          3.9\n 2 Kedah          2756 state            5522             3359 0.354          8.8\n 3 Kelantan       1428 state            4874             3223 0.378         12.4\n 4 Melaka         1215 state            7741             4955 0.383          3.9\n 5 Negeri Semb…   1546 state            6707             4350 0.391          4.3\n 6 Pahang         1037 state            5667             3652 0.33           4.3\n 7 Perak          2168 state            5645             3564 0.377          7.3\n 8 Perlis          199 state            5476             3468 0.334          3.9\n 9 Perlis          199 district         5476             3468 0.334          3.9\n10 Pulau Pinang   2085 state            7774             4630 0.359          1.9\n11 Sabah          3212 state            5745             2792 0.397         19.5\n12 Sarawak        1796 state            5959             3448 0.387          9  \n13 Selangor      11028 state           10827             5830 0.393          1.2\n14 Terengganu      905 state            6815             4336 0.335          6.1\n15 W.P. Kuala …   2861 state           13257             6913 0.35           0.2\n16 W.P. Kuala …   2861 district        13257             6913 0.35           0.2\n17 W.P. Labuan     159 state            8319             4097 0.333          3.1\n18 W.P. Labuan     159 district         8319             4097 0.333          3.1\n19 W.P. Putraj…     29 state           12840             7980 0.361          0.4\n20 W.P. Putraj…     29 district        12840             7980 0.361          0.4\n```\n:::\n:::\n\n\nDoes `inner_join` give different results to `left_join` in the above example?\n\n### Right Join\n\nThe `right_join()` function is like the `left_join()` function except that it **gives priority to the \"right\" hand argument**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_join(x = state_df, y = hies_df, by = join_by(state==area))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 998 × 7\n   state        deaths area_type income_mean expenditure_mean  gini poverty_rate\n   <chr>         <int> <chr>           <int>            <int> <dbl>        <dbl>\n 1 Johor          4741 state            8013             4793 0.366          3.9\n 2 Kedah          2756 state            5522             3359 0.354          8.8\n 3 Kelantan       1428 state            4874             3223 0.378         12.4\n 4 Melaka         1215 state            7741             4955 0.383          3.9\n 5 Negeri Semb…   1546 state            6707             4350 0.391          4.3\n 6 Pahang         1037 state            5667             3652 0.33           4.3\n 7 Perak          2168 state            5645             3564 0.377          7.3\n 8 Perlis          199 state            5476             3468 0.334          3.9\n 9 Perlis          199 district         5476             3468 0.334          3.9\n10 Pulau Pinang   2085 state            7774             4630 0.359          1.9\n# ℹ 988 more rows\n```\n:::\n:::\n\n\nWhat about now?\n\n![](/images/normal.png)\n\n## Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://stephaniehicks.com/jhustatcomputing2022/>\n\n-   [The Epidemiologist R Handbook](https://epirhandbook.com/en/index.html)\n\n-   <https://rafalab.github.io/dsbook>\n\n-   <https://rmd4sci.njtierney.com>\n\n## Additional Resources\n\n::: callout-tip\n-   <https://r4ds.had.co.nz/tibbles.html>\n-   <https://jhudatascience.org/tidyversecourse/wrangle-data.html#data-wrangling>\n-   [dplyr cheat sheet from RStudio](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)\n:::\n",
    "supporting": [
      "session1_wranggling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}